# 日程功能极限测试用例

## 📋 测试目的
验证日程功能在各种极限条件下的稳定性和正确性

---

## 🗓️ 一、日期边界测试

### 测试1.1：月初日期（1号）
**测试步骤**：
1. 点击任意月份的1号
2. 创建日程：标题"月初测试"，时间09:00
3. 保存并验证

**预期结果**：
- ✅ 日程成功保存到1号
- ✅ 日程在日历上显示小圆点
- ✅ 点击1号显示该日程

**SQL验证**：
```sql
SELECT title, schedule_date FROM schedules
WHERE title = '月初测试'
AND DAY(schedule_date) = 1;
```

---

### 测试1.2：月末日期（28/29/30/31号）
**测试步骤**：
1. 测试2月28日（平年）
2. 测试2月29日（闰年，如2024年）
3. 测试4月30日（30天的月份）
4. 测试1月31日（31天的月份）

**预期结果**：
- ✅ 所有日期都能正常保存
- ✅ 2月29日在非闰年不可点击

**SQL验证**：
```sql
SELECT title, schedule_date FROM schedules
WHERE DAY(schedule_date) >= 28
ORDER BY schedule_date;
```

---

### 测试1.3：跨月日程查询
**测试步骤**：
1. 在11月30日创建日程"月末"
2. 在12月1日创建日程"月初"
3. 切换月份查看

**预期结果**：
- ✅ 11月只显示30日的日程
- ✅ 12月只显示1日的日程
- ✅ 不会出现日程错位

---

### 测试1.4：跨年日程
**测试步骤**：
1. 在2025年12月31日创建日程"跨年夜"
2. 在2026年1月1日创建日程"新年"
3. 切换年份查看

**预期结果**：
- ✅ 年份切换正常
- ✅ 日程不会跨年显示

---

### 测试1.5：闰年2月29日
**测试数据**：
- 闰年：2024年2月29日
- 平年：2025年2月（无29日）

**测试步骤**：
1. 在2024年2月创建29日的日程
2. 切换到2025年2月

**预期结果**：
- ✅ 2024年2月有29日可点击
- ✅ 2025年2月只显示28天
- ✅ 日程只在2024年显示

**SQL验证**：
```sql
SELECT * FROM schedules
WHERE schedule_date = '2024-02-29';
```

---

### 测试1.6：极远未来日期
**测试数据**：2099年12月31日

**测试步骤**：
1. 通过年月选择器选择2099年12月
2. 点击31日创建日程"未来测试"

**预期结果**：
- ✅ 可以正常创建
- ✅ 查询时能正确返回
- ✅ 日期显示正确

---

### 测试1.7：极远过去日期
**测试数据**：1900年1月1日

**测试步骤**：
1. 选择1900年1月
2. 创建日程"历史测试"

**预期结果**：
- ✅ 系统接受该日期
- ✅ 能正确存储和显示

---

## ⏰ 二、时间边界测试

### 测试2.1：午夜时间（00:00）
**测试步骤**：
1. 创建日程，时间选择00:00
2. 保存并查看

**预期结果**：
- ✅ 显示为"00:00"而非"12:00 AM"
- ✅ 时间正确保存到数据库

**SQL验证**：
```sql
SELECT title, start_time FROM schedules
WHERE start_time = '00:00:00';
```

---

### 测试2.2：接近午夜时间（23:59）
**测试步骤**：
1. 创建日程，时间选择23:59
2. 保存并查看

**预期结果**：
- ✅ 显示为"23:59"
- ✅ 不会溢出到第二天

---

### 测试2.3：全天日程
**测试步骤**：
1. 创建日程时不选择时间（或选择"全天"）
2. 保存

**预期结果**：
- ✅ `isAllDay` 为 true
- ✅ `startTime` 和 `endTime` 为 null
- ✅ 显示为"全天"

**SQL验证**：
```sql
SELECT title, is_all_day, start_time FROM schedules
WHERE is_all_day = 1;
```

---

## 📊 三、数据量测试

### 测试3.1：单日多个日程
**测试步骤**：
1. 在同一天创建10个日程
2. 创建20个日程
3. 创建50个日程（压力测试）

**预期结果**：
- ✅ 所有日程都能正常保存
- ✅ 列表滚动流畅
- ✅ 日历小圆点正常显示
- ✅ 查询性能可接受（< 1秒）

**SQL验证**：
```sql
SELECT COUNT(*) as count, schedule_date
FROM schedules
GROUP BY schedule_date
HAVING count > 10;
```

---

### 测试3.2：单月大量日程
**测试步骤**：
1. 在一个月内创建100+个日程（分散到各个日期）
2. 切换月份查看

**预期结果**：
- ✅ 月份切换流畅
- ✅ 日历渲染正常
- ✅ 查询速度可接受

---

### 测试3.3：快速连续创建
**测试步骤**：
1. 快速连续点击保存按钮10次（模拟误操作）
2. 快速创建5个日程（间隔<1秒）

**预期结果**：
- ✅ 不会创建重复日程
- ✅ 不会崩溃
- ✅ 每个日程都有唯一ID

---

## 📝 四、字段边界测试

### 测试4.1：标题长度测试
**测试数据**：

**极短标题**（1字符）：
```
A
```

**正常标题**（10字符）：
```
团队周会讨论
```

**长标题**（100字符）：
```
这是一个非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常长的日程标题测试这是一个非常非常非常非常非常非常非常非常非常非常非常
```

**超长标题**（200字符，边界值）：
```
测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
```

**超出限制**（201字符，应该被拦截）：
```
[201个字符的标题]
```

**预期结果**：
- ✅ 1字符可以保存
- ✅ 100字符正常显示
- ✅ 200字符成功保存
- ❌ 201字符应该被拒绝或截断

---

### 测试4.2：特殊字符测试
**测试数据**：

```
标题包含特殊字符：!@#$%^&*()_+-=[]{}|;:'",.<>?/~`
```

**预期结果**：
- ✅ 特殊字符正确保存
- ✅ 前端正确显示
- ✅ SQL注入攻击被防御

**安全验证**：
```
标题：'; DROP TABLE schedules; --
```
**预期结果**：
- ✅ 作为普通文本保存
- ✅ 不会执行SQL

---

### 测试4.3：Emoji表情测试
**测试数据**：
```
🎉 生日派对 🎂
📅 重要会议 💼
🏃‍♂️ 晨跑 ⏰
❤️💛💚💙💜
```

**预期结果**：
- ✅ Emoji正确保存到数据库
- ✅ 前端正确显示
- ✅ 不会出现乱码

**SQL验证**：
```sql
SELECT title FROM schedules
WHERE title LIKE '%🎉%';
```

---

### 测试4.4：地点长度测试
**测试数据**：
- 短地点：`北京`
- 长地点：`北京市朝阳区建国门外大街1号国贸大厦A座3层会议室301室（地铁1号线国贸站C口出，向东100米）`
- 超长地点：200字符的地址

**预期结果**：
- ✅ 所有长度都能正常保存
- ✅ 前端显示时适当截断或换行

---

### 测试4.5：空值和Null测试
**测试数据**：
- 标题：不能为空（前端应该禁用保存按钮）
- 地点：可以为空
- 时间：可以为空（全天日程）

**预期结果**：
- ❌ 空标题无法保存
- ✅ 空地点可以保存（location = null）
- ✅ 空时间可以保存（isAllDay = true）

---

## 🔐 五、认证和权限测试

### 测试5.1：Token过期
**测试步骤**：
1. 登录并等待Token过期（2小时）
2. 尝试创建日程

**预期结果**：
- ❌ 返回401未授权错误
- ✅ 前端提示"请重新登录"
- ✅ 不会崩溃

---

### 测试5.2：未登录状态
**测试步骤**：
1. 清除本地Token
2. 尝试创建日程

**预期结果**：
- ❌ 显示"用户未登录"错误
- ✅ 引导用户去登录页

---

### 测试5.3：跨用户访问
**测试步骤**：
1. 用户A创建日程
2. 获取日程ID
3. 用户B尝试删除该日程

**预期结果**：
- ❌ 返回"日程不存在"或"无权限"
- ✅ 后端验证userId匹配

**SQL验证**：
```sql
-- 应该只能查到自己的日程
SELECT * FROM schedules
WHERE user_id = 'user_a_id';
```

---

## 🌐 六、网络异常测试

### 测试6.1：创建时断网
**测试步骤**：
1. 填写日程信息
2. 关闭WiFi/移动网络
3. 点击保存

**预期结果**：
- ❌ 显示"网络错误"提示
- ✅ 不会崩溃
- ✅ 数据保留在输入框（可重试）

---

### 测试6.2：加载时断网
**测试步骤**：
1. 关闭网络
2. 切换月份

**预期结果**：
- ❌ 显示"无法加载日程"
- ✅ 显示上次缓存的数据（如果有）
- ✅ 网络恢复后可重新加载

---

### 测试6.3：弱网环境
**测试步骤**：
1. 使用网络限速工具（如Chrome DevTools）
2. 模拟2G网络速度
3. 创建和加载日程

**预期结果**：
- ✅ 显示加载指示器
- ✅ 最终成功加载
- ✅ 超时合理（30秒）

---

## 🔄 七、并发和竞态测试

### 测试7.1：同时编辑
**测试步骤**：
1. 打开同一个日程的编辑界面
2. 在两个设备上同时修改
3. 保存

**预期结果**：
- ✅ 后保存的覆盖先保存的
- ✅ 数据一致性

---

### 测试7.2：编辑冲突
**测试步骤**：
1. 设备A：编辑日程但不保存
2. 设备B：删除该日程
3. 设备A：点击保存

**预期结果**：
- ❌ 返回"日程不存在"
- ✅ 友好提示用户

---

## 🗑️ 八、删除操作测试

### 测试8.1：逻辑删除验证
**测试步骤**：
1. 创建日程
2. 删除日程
3. 检查数据库

**预期结果**：
- ✅ 前端不再显示
- ✅ 数据库中 `is_deleted = 1`
- ✅ 数据仍然存在（可恢复）

**SQL验证**：
```sql
SELECT * FROM schedules
WHERE is_deleted = 1;
```

---

### 测试8.2：删除后再创建
**测试步骤**：
1. 在某天创建日程"会议"
2. 删除该日程
3. 同一天再创建相同标题的日程

**预期结果**：
- ✅ 生成新的scheduleId
- ✅ 两条记录独立存在

---

## 📱 九、前端性能测试

### 测试9.1：大量日程渲染
**测试步骤**：
1. 创建100个日程
2. 切换到该月份
3. 观察渲染时间

**预期结果**：
- ✅ 初次渲染 < 2秒
- ✅ 滚动流畅（60fps）
- ✅ 内存占用合理（< 200MB）

---

### 测试9.2：快速切换月份
**测试步骤**：
1. 快速点击"上一月"/"下一月"按钮
2. 观察动画和加载

**预期结果**：
- ✅ 动画流畅
- ✅ 不会重复请求
- ✅ 数据正确

---

## 🔍 十、SQL查询测试

### 测试10.1：跨月查询边界
**SQL测试**：
```sql
-- 查询2025年11月的日程（应该不包含10月31日和12月1日）
SELECT * FROM schedules
WHERE user_id = 'test-user-id'
  AND schedule_date >= '2025-11-01'
  AND schedule_date < '2025-12-01'
  AND is_deleted = 0;
```

**预期结果**：
- ✅ 只返回11月1日-30日的日程
- ✅ 性能良好（有索引）

---

### 测试10.2：复合索引效率
**SQL测试**：
```sql
EXPLAIN SELECT * FROM schedules
WHERE user_id = 'test-user-id'
  AND schedule_date >= '2025-11-01'
  AND schedule_date < '2025-12-01'
  AND is_deleted = 0;
```

**预期结果**：
- ✅ 使用索引 `idx_user_date`
- ✅ type = ref 或 range
- ✅ rows < 100

---

## 📋 测试检查清单

### 功能完整性
- [ ] 创建日程
- [ ] 查询日程
- [ ] 更新日程
- [ ] 删除日程

### 边界值测试
- [ ] 最小日期
- [ ] 最大日期
- [ ] 最短标题
- [ ] 最长标题
- [ ] 空字段
- [ ] 特殊字符

### 性能测试
- [ ] 单日多个日程（10+）
- [ ] 单月大量日程（100+）
- [ ] 快速切换月份
- [ ] 并发创建

### 异常处理
- [ ] 网络断开
- [ ] Token过期
- [ ] 服务器错误
- [ ] 数据冲突

### 安全性测试
- [ ] SQL注入防御
- [ ] XSS攻击防御
- [ ] 跨用户访问控制
- [ ] Token验证

---

## 🎯 自动化测试建议

### 创建测试数据的SQL脚本
```sql
-- 清理测试数据
DELETE FROM schedules WHERE user_id LIKE 'test-%';

-- 批量创建测试数据
INSERT INTO schedules (schedule_id, user_id, title, schedule_date, start_time, is_all_day, is_deleted)
VALUES
  (UUID(), 'test-user-1', '月初测试', '2025-11-01', '09:00', 0, 0),
  (UUID(), 'test-user-1', '月末测试', '2025-11-30', '18:00', 0, 0),
  (UUID(), 'test-user-1', '跨年测试', '2025-12-31', '23:59', 0, 0),
  (UUID(), 'test-user-1', '闰年测试', '2024-02-29', '12:00', 0, 0),
  (UUID(), 'test-user-1', '全天测试', '2025-11-15', NULL, 1, 0),
  (UUID(), 'test-user-1', 'Emoji测试🎉', '2025-11-16', '10:00', 0, 0);

-- 创建大量测试数据（性能测试）
DELIMITER $$
CREATE PROCEDURE create_test_schedules(IN num_schedules INT)
BEGIN
    DECLARE i INT DEFAULT 0;
    WHILE i < num_schedules DO
        INSERT INTO schedules (schedule_id, user_id, title, schedule_date, start_time, is_all_day, is_deleted)
        VALUES (
            UUID(),
            'test-user-1',
            CONCAT('测试日程-', i),
            DATE_ADD('2025-11-01', INTERVAL FLOOR(RAND() * 30) DAY),
            CONCAT(FLOOR(RAND() * 24), ':', FLOOR(RAND() * 60)),
            0,
            0
        );
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;

-- 调用存储过程创建100个测试日程
CALL create_test_schedules(100);
```

---

## 🔧 测试工具推荐

1. **Postman/Insomnia**：API接口测试
2. **JMeter**：性能压力测试
3. **Chrome DevTools**：网络限速测试
4. **ADB logcat**：Android日志监控
5. **MySQL Workbench**：数据库验证

---

## 📊 测试报告模板

```
测试日期：2025-11-26
测试人员：[姓名]
测试环境：
  - 后端：Spring Boot 3.5.7 + MySQL 8.0
  - 前端：Android API 34
  - 网络：WiFi / 4G

测试结果：
  ✅ 通过：[数量]
  ❌ 失败：[数量]
  ⚠️  警告：[数量]

失败用例详情：
1. [用例编号] - [失败原因] - [优先级]

建议改进：
1. [建议内容]
```

---

**测试原则**：
1. 先测试正常流程，再测试边界条件
2. 每个测试用例独立，可重复执行
3. 记录失败的详细信息（截图、日志）
4. 优先修复影响核心功能的bug

**文档版本**：v1.0
**最后更新**：2025-11-26
